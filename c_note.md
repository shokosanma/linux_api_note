# gcc编译

## gcc编译4步骤

预处理: gcc -E、展开宏，头文件，替换条件编译，删除注释、空白、空行

编译: gcc -S、检查语法规范（此阶段消耗时间和系统资源最多）

汇编: gcc -c、将汇编指令翻译成机器指令

链接: 无参数、数据段合并、地址回填

## gcc常用参数

-I 	（大写i）指定头文件目录

-c		只做预处理,编译,和汇编。得到二进制文件

-g		编译时添加调试语句，使之支持gdb调试

-Wall	显示所有警告

-D		向程序中“动态”注册宏定义。（例如：gcc hello.c -D HELLO 10）

# 静态库和共享库（动态库）

静态库：对空间要求较低，对时间要求较高

共享库：和静态库相反

## 静态库制作及使用

1. 将.c 文件生成.o文件

```
gcc -c xxxx.c -o xxxx.o
```

2. 使用ar rsc命令生成静态库.a文件，其中xxx是可以自己命名的部分

```
ar rsc libxxx.a file1.o
```

gcc编译生成可执行程序时报错主要出现在两个地方：1.编译，2.链接。编译阶段报错会有行号，链接阶段报错没有行号，存在collect2。

使用静态库，编译静态库到可执行文件中，注意顺序，源码在前，库在后

```
gcc test.c libxxx.a -o test
```

另外，静态库应该配合头文件使用，头文件结构可以如下

```
#ifndef _HEAD_H_
#define _HEAD_H_
int func1(int, char);
char func2(int);
...
#endif
```

## 动态库制作

1. 将.c 文件生成.o文件，生成与位置无关的代码（-fPIC）

```
gcc -c xxxx.c -o xxxx.o -fPIC
```

2. 使用gcc -shared命令制作动态库，其中xxx是可以自己命名的部分

```
gcc -shared -o libxxx.so file.o
```

3. 编译可执行程序时，指定所用的动态库。-l：指定库名，-L：指定库的路径

```
gcc test.c -o a.out -l mylib -L
```

至此，直接执行./a.out会出错，原因：

动态链接器：	工作于程序运行阶段，1.工作时需要提供动态库所在目录位置（通过环境变量中的LD_LIBRARY_PATH提供）

```
export LD_LIBRARY_PATH=./lib
```

2.动态链接器也可以通过将动态库路径加入/etc/ld.so.conf文件中，并执行

```
ldconfig -v
```

使之生效，3.也可以将libxxx.so文件复制移动到系统的动态库目录/lib下

查看a.out依赖的动态库命令

```
ldd a.out
```

另外，链接器：			工作于程序编译的链接阶段，工作时需要 -l和 -L。和动态链接器没有关系。

## 内存结构

内存自上倒下各部分划分

1. 内核kernel

2. 用户空间user

   2.1 stack--也就是栈段，常说的堆栈段之一，是由系统负责申请释放，其操作方式类似stack，用于存储参数变量及局部变量，其实函数的执行也是stack的方式，所以才有了递归

   2.2 heap--也就是俗称的堆，它由用户申请和释放，申请时至少分配虚存，当真正存储数据时才分配相应的实存，释放时也并非立即释放实存，而是可能被重复利用

   2.3 .bss--通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。该段用于存储未初始化的全局变量或者是默认初始化为0的全局变量，它不占用程序文件的大小，但是占用程序运行时的内存空间。

   2.4 .data--该段用于存储初始化的全局变量，初始化为0的全局变量出于编译优化的策略还是被保存在BSS段。

   2.5 .rodata--该段也叫常量区，用于存放常量数据，ro就是Read Only之意。但是注意并不是所有的常量都是放在常量数据段的，其特殊情况如下：
   1）有些立即数与指令编译在一起直接放在代码段。

   2）对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份。

   2.6 .text--用于存放程序代码的，编译时确定,只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。

动态库加载占用内存位置在stack和heap之间，环境变量在stack上方，内核下方。

32位系统页大小为4K，则.text、.rodata等至少占用4K内存，编译中链接阶段对只读数据段和读写数据段进行数据段合并，可以减少内存占用。

# gdb调试

编译gdb可调试执行文件，gcc编译时加-g参数

```
gcc test.c -o a.out -g
```

gdb调试，输入

```
gdb a.out
```

进入交互调试，调试命令如下：

| 调试指令         | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| break xxx、b xxx | 在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点的位置。 |
| run、r           | 执行被调试的程序，其会自动在第一个断点处暂停执行。           |
| continue、c      | 当程序在某一断点处停止运行后，使用该指令可以继续执行，直至遇到下一个断点或者程序结束。 |
| next、n          | 执行下一条指令（会越过函数）。                               |
|step、s			  |	执行下一条指令（会进入自定义函数，遇到系统定义函数报错）。		|
| print xxx、p xxx | 打印指定变量的值，其中 xxx 指的就是某一变量名。              |
| list、l          | 显示源程序代码的内容，包括各行代码所在的行号。               |
| quit、q          | 终止调试。                                                   |

查找段错误，直接使用run命令，会报出段错误出现位置

finish：结束当前函数调用

## 段错误

段错误是计算机软件运行过程中可能出现的一种特殊错误情况。当程序试图访问不允许访问的内存位置，或试图以不允许的方式访问内存位置（例如尝试写入只读位置，或覆盖部分操作系统）时会发生段错误。

两篇博文

https://www.cnblogs.com/no7dw/archive/2013/02/20/2918372.html

https://blog.csdn.net/qq_35703848/article/details/90670581

# makefile

具体可见https://github.com/ABottomCoder/Linux-system-programming